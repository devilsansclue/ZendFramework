<?xml version="1.0" encoding="UTF-8"?>
<sect1 id="zend.entity.quickstart">
    <sect2 id="zend.entity.quickstart.entity">
        <title>Entities</title>

        <para>
            Entities are leightweight PHP Objects that don't need to extend any abstract base class
            or interface. An entity must be instantiable with no additional constructor arguments
            and may not have any public final method.
        </para>

        <para>
            An entity contains persistable properties. A persistable property is an instance variable
            of the entity that contains the data which is persisted and retrieved by the data mapper.
            Depending on the access strategy that is chosen to inject and retrieve these persistent
            properties certain set and get strategies have to be implemented, which are discussed
            in more detail at a later stage.
        </para>
    </sect2>

    <sect2 id="zend.entity.quickstart.model">
        <title>An Example Model: Bug Tracker</title>

        <para>
            For this quickstart into the Zend_Entity we will re-implement the Bug Tracker domain model from the
            Zend_Db_Table documentation. For storage the Database Mapper is used in conjunction with 
            Zend Entity. We will begin by stating the requirements:
        </para>

        <itemizedlist>
            <listitem>A Bugs has a description, creation date, status, reporter and engineer</listitem>
            <listitem>A bug can occour on different products (platforms)</listitem>
            <listitem>Products have a name.</listitem>
            <listitem>Bug Reporter and Engineers are both Users of the System.</listitem>
            <listitem>A user can create new bugs.</listitem>
            <listitem>The assigned engineer can close a bug.</listitem>
            <listitem>A user can see all his reported or assigned bugs.</listitem>
            <listitem>Bugs can be paginated through a list-view.</listitem>
        </itemizedlist>

    </sect2>

    <sect2 id="zend.entity.quickstart.ddd">
        <title>A domain driven design</title>

        <para>
           A first simplified design for this domain model might look like the following set of classes:
        </para>

        <programlisting language="php"><![CDATA[
class Bug
{
    public $id;
    public $description;
    public $created;
    public $status;
    public $products = array();
    public $reporter;
    public $engineer;
}
class Product
{
    public $id;
    public $name;
}
class User
{
    public $id;
    public $name;
    public $reportedBugs = array();
    public $assignedBugs = array();
}
]]>
        </programlisting>

        <para>
            Because we will focus on the mapping aspect, no effort is being made to encapsulate the business logic.
            All peristable properties are being made public. The Data Mapper can use the access strategy "Property"
            to set and get values, which is an approach using ReflectionProperty::setValue() and ReflectionProperty::getValue().
            If you are on PHP 5.3 this access strategy would still work if the properties are set to private or
            protected at a later revision of our domain model.
        </para>

        <para>
            There are several references between objects in this domain model, whose semantics are discussed case
            by case at this point to explain how Zend Entity handles them. In general each OneToOne or ManyToOne Relation
            in the Database is replaced by an instance of the related object in the domain model. Each OneToMany or
            ManyToMany Relation is replaced by a collection of instances in the domain model. Given our domain model
            this would lead to the whole database being loaded into memory upon retrieval of an entity. However by
            default Zend_Entity uses or generates LazyLoad implementations of entities or collections. To be able
            to use lazyload with collections, simple PHP arrays have to be replaced with the use of a generic collection
            class <classname>Zend_Entity_Collection</classname> which tries to act as array as much as possible
            using <classname>ArrayAccess</classname>, <classname>Iterator</classname> and <classname>Countable</classname>
            interfaces. We have to clear up our domain model to cope with the assumptions about related collections:
        </para>

        <programlisting language="php"><![CDATA[
class Bug
{
    public $products = null;

    public function __construct()
    {
        $this->products = new Zend_Entity_Collection();
    }
}

class User
{
    public $reportedBugs = null;
    public $assignedBugs = null;

    public function __construct()
    {
        $this->reportedBugs = new Zend_Entity_Collection();
        $this->assignedBugs = new Zend_Entity_Collection();
    }
}
]]>
        </programlisting>

        <para>
            Whenever an entity is recreated from persistence, a collection is also injected instead of an array.
        </para>

        <warning>
            <para>
                The Lazy load proxies always contain an instance of the Entity Manager and all its dependencies.
                Therefore a var_dump() will try to dump a very large recursive structure which is impossible
                to read. Use a debugger like Zend Debugger or XDebug to check for variable content.
            </para>
        </warning>

        <important>
            <para>
                Don't exchange the underlying collection classes between recreation and persistence. Zend Entity
                keeps track of the specific collections using <code>spl_object_hash()</code> and throws an Exception
                if the collection created from persistence is not the same like the one being persisted. This mechanism
                is for security, so that you don't accidently delete references and related objects.
            </para>
        </important>

        <para>
            Because we only work with collections for the references we must be careful to
            implement a bidirectional reference in the domain model. The concept of owning or inverse side of a relation
            is central to this notion and should always be kept in mind. The following assumptions are made about
            relations and have to be followed to be able to work with the Database Mapper. These assumptions are
            not unique to Zend Entity and the Database Mapper but are best practices in handling database relations
            and Object-Relational Mapping.
        </para>

        <itemizedlist>
            <listitem>Changes to Collections are saved or updated, when the entity on the owning side of the collection is saved or updated.</listitem>
            <listitem>Saving an Entity at the inverse side of a relation never triggers a persist operation to changes to the collection.</listitem>
            <listitem>In a one-to-one relation the entity persisting the foreign key of the related entity is the owning side of the relation.</listitem>
            <listitem>In a many-to-many relation, both sides can be the owning side of the relation. However even in a bi-directional many-tomany relation only one should be.</listitem>
            <listitem>In a many-to-one relation the Many-side is the owning side by default, because it holds the foreign key.</listitem>
            <listitem>
                The OneToMany side of a relation is inverse by default, since the foreign key is saved on the Many side.
                This can only be reversed by the use a third additional table holding the primary keys of each entity,
                like in the many to many case, utilizing a UNIQUE constraint on the id of the ToOne entity.
                Using this approach the foreign key on the many side is not required anymore. Rendering it the inverse
                side of the relation.
            </listitem>
        </itemizedlist>

        <important>
            <para>
                Consistency of bi-directional references on the inverse side of a relation have to be managed
                in userland application code. Zend Entity cannot magically update your collections to be consistent.
            </para>
        </important>

        <para>
            In the case of Users and Bugs we have references back and forth to the assigned and reported bugs from a user, making this relation
            bi-directional. We have to change the code to ensure consistency of the bi-directional reference:
        </para>

        <programlisting language="php"><![CDATA[
class Bug
{
    protected $engineer;
    protected $reporter;

    public function setEngineer($engineer)
    {
        $engineer->assignedToBug($this);
        $this->engineer = $engineer;
    }

    public function setReporter($reporter)
    {
        $reporter->addReportedBug($this);
        $this->reporter = $reporter;
    }

    public function getEngineer()
    {
        return $this->engineer;
    }

    public function getReporter()
    {
        return $this->reporter;
    }
}
class User
{
    public function addReportedBug($bug)
    {
        $this->reportedBugs[] = $bug;
    }

    public function assignedToBug($bug)
    {
        $this->assignedBugs[] = $bug;
    }
}
]]>
        </programlisting>

        <para>
            I chose to name the inverse methods in past-tense, which should indicate that the actual assigning
            has already taken place and the methods are only used for ensuring consistency of the references.
            You can see from <code>User::addReportedBug()</code> and <code>User::assignedToBug()</code>
            that using this method in userland alone would not add the Bug
            to the collection of the owning side in <code>Bug::$reporter</code> or <code>Bug::$engineer</code>.
            Only using <code>Bug::setEngineer()</code> or <code>Bug::setReporter</code> correctly
            saves the relation information. You may also realize that when setting both collection instance variables
            to protected, our chosen access strategy "Property" now requires PHP 5.3 to be able to use Reflection against
            the protected properties.
        </para>

        <para>
            The <code>Bug::$reporter</code> and <code>Bug::$engineer</code> properties are qualified Many-To-One relations,
            which point to a User. In the relational model the foreign key is saved on the Bug's table, hence the Bug
            is at the owning side of the relation. Thinking about our use-cases this direction of the relation is also
            the important for our domain model. Whenever a new bug is saved or an engineer is assigned, we don't want to
            save the User to persist the reference, but the Bug. This is the case with the Bug being at the owning side
            of the relation.
        </para>

        <para>
            Bugs reference Products by a uni-directional ManyToMany relation in the database that points from
            from Bugs to Products.
        </para>

        <programlisting language="php"><![CDATA[
class Bug
{
    protected $products = null; // Make protected for encapsulation

    public function assignToProduct($product)
    {
        $this->products[] = $product;
    }

    public function getProducts()
    {
        return $this->products;
    }
}
]]>
        </programlisting>

        <para>
            We are now finished with the domain model. From the public property only model we had to do
            quite some work to get to a model where we encapsulated the relational data to ensure a consistent
            state. However up to now the assumptions we have to follow are not restricting us much in our
            domain modelling capabilities, because we would have encapsulated access to all the properties
            anyways by applying object-oriented best-practices.
        </para>

    </sect2>

    <sect2 id="zend.entity.quickstart.metadata">
        <title>Metadata for Entities</title>

        <para>
            The next step to persisting our domain model is to describe the structure of it to Zend Entity
            using a metadata language. This metadata language describes how entities, their properties and
            references should be persisted and what constraints should be applied to them. The metadata
            description is independent of the underyling storage, although parts of the naming reflect
            the intend to use Zend Entity with a relational database management system. However the metadata
            can be used by any mapping backend, the visitor pattern allows to transform the defined metadata
            into a structure that is useful for the mapping implementation at hand. In our example we
            will keep implementing the domain model for the Database mapper.
        </para>

        <para>
            Metadata for entities are loaded using a <classname>Zend_Entity_MetadataFactory_Interface</classname>
            implementation. We will use a programmatic implementation using PHP Code here.
        </para>

        <programlisting language="php"><![CDATA[
$pathToMetadataDirectory = "/path/to";
$metadataFactory = new Zend_Entity_MetadataFactory_Code($pathToMetadataDirectory);
]]>
        </programlisting>

        <para>
            This programmatic implementation now requires the files Bug.php, Product.php and User.php inside
            the given metadata directory. We begin by specifying the definition of a Bug:
        </para>

        <programlisting language="php"><![CDATA[
$def = new Zend_Entity_Definition_Entity("Bug");
$def->setTable("zfbugs");
$def->setAccess("Property");

$def->addPrimaryKey("id", array(
    "columnName" => "bug_id",
    "generator" => new Zend_Entity_Definition_Id_AutoIncrement()
));

$def->addProperty("description", array("columnName" => "bug_description"));
$def->addProperty("created", array(
    "columnName" => "bug_created",
    "propertyType" => Zend_Entity_Definition_Property::TYPE_DATETIME,
));
$def->addProperty("status", array(
    "columnName" => "bug_status",
));

$def->addManyToOneRelation("reporter", array(
    "columnName" => "reported_by",
    "class" => "User",
));

$def->addManyToOneRelation("engineer", array(
    "columnName" => "assigned_to",
    "class" => "User",
));

$def->addCollection("products", array(
    "relation" => new Zend_Entity_Definition_ManyToManyRelation(array(
        "class" => "Product",
        "columnName" => "product_id", // Join Column Product Key
        "inverse" => false, // Mark as owning
    )),
    "table" => "zfbugs_products", // Join Table Name
    "key" => "bug_id", // Join Table Bug Key
));

return $def;
]]>
        </programlisting>

        <para>
            The toplevel entity definition gets information about the classname, its table
            and what access strategy is chosen to get and set values. All the properties are
            then defined. <code>$def->addProperty($propertyName, $options)</code> creates a simple
            property that translates to a single column in the database. The column names are
            used from the <classname>Zend_Db_Table</classname> examples and have different names
            than the properties. Additionally for the "created" field it is specified that it is
            of the Type "DATETIME", which translates the YYYY-mm-dd HH:mm:ss Database format
            into a PHP <classname>Datetime</classname> instance and back.
        </para>

        <para>
            After that the two qualified references to the user entity are given. They are created
            by calling <code>$def->addManyToOneRelation($propertyName, $options);</code>. The
            class name of the related entity has to be specified, which is enough for the database
            mapper to guess foreign-table, foreign-key and identity key to make built a correct
            query statement.
        </para>

        <para>
            The last defined property is the collection of products a bug is occuring on.
            It is explicitly defined as collection by calling <code>$def->addCollection($propertyName, $options);</code>.
            Then the underyling relation has to be specified as instance of
            <classname>Zend_Entity_Definition_ManyToManyRelation</classname>. The collection defines the name
            of the join table and the join table key of the bug, the options of the
            many to many relation specify the related class and its join table key.
            As discussed the relation is marked as owning by setting inverse to false.
        </para>

        <important>
            <para>
                Note how with the Code MetadataFactory the Definition has to be returned from the "Bug.php" file.
                Otherwise an exception is thrown that the definition cannot be found.
            </para>
        </important>

        <para>The next discussed definition will be for the Product</para>

        <programlisting language="php"><![CDATA[
$def = new Zend_Entity_Definition_Entity("Product");
$def->setTable("zfproducts");
$def->setAccess("Property");

$def->addPrimaryKey("id", array(
    "columnName" => "product_id",
    "generator" => new Zend_Entity_Definition_Id_AutoIncrement(),
));

$def->addProperty("name", array(
    "columnName" => "product_name",
));

return $def;
]]>
        </programlisting>

        <para>
            The only new detail in this definition is the inverse many-to-many
            specification, which has inverse set to true and because of this is required
            to set the "mappedBy" option to the property on Bug, which holds the owning side
            of the collection.
        </para>

        <para>The last missing definition is that of the User entity:</para>

        <programlisting language="php"><![CDATA[
$def = new Zend_Entity_Definition_Entity("User");
$def->setTable("zfaccounts");
$def->setAccess("Property");

$def->addPrimaryKey("id", array(
    "columnName" => "account_id",
    "generator" => new Zend_Entity_Definition_Id_AutoIncrement(),
));

$def->addProperty("name", array(
    "columnName" => "account_name",
));

$def->addCollection("reportedBugs", array(
    "relation" => new Zend_Entity_Definition_OneToManyRelation(array(
        "class" => "Bug",
        "inverse" => true,
        "mappedBy" => "reporter"
    )),
    "key" => "reported_by",
));

$def->addCollection("assignedBugs", array(
    "relation" => new Zend_Entity_Definition_OneToManyRelation(array(
        "class" => "Bug",
        "inverse" => true,
        "mappedBy" => "engineer"
    )),
    "key" => "assigned_to",
));

return $def;
]]>
        </programlisting>

        <para>
            Here the only new detail is the definition of a OneToMany collection.
            Since this collection is the inverse side of the relation we don't need
            to specifiy the table option key in comparison to the ManyToMany example,
            since the table can be inferred from the given "Bug" class to construct
            queries for that collection internally.
        </para>

        <para>
            This example has a fair overview of the most basic features of the metadata
            definition language. In the section "Extending the Example Model: Advanced Features"
            the more advanced properties that will be introduced in the manual will be put
            to practice by extending this example model.
        </para>

    </sect2>

    <sect2 id="zend.entity.quickstart.entitymanager">
        <title>Creating an Entity Manager and Mapping Backend</title>

        <para>
            Now that we have defined our Domain model and written all the metadata definitions
            we can create the <classname>Zend_Entity_Manager</classname> which offers a public
            interface to the mapping process between persistence and object model. The Entity
            Manager handles all the lifecycle actions of an entity from initial persistence,
            updating and removing.
        </para>

        <para>
            We will now instantiate the Entity Manager in the context of the database mapper.
            First we need a Database Adapter, the Metadata Factory and create the Database Mapper,
            all of which can then be used to instantiate the Entity Manager:
        </para>

        <programlisting language="php"><![CDATA[
$db = Zend_Db::factory($dbConfig);
$metadataFactory = new Zend_Entity_MetadataFactory_Code($metadataPath);
$mapper = Zend_Db_Mapper_Mapper::create(array('db' => $db, 'metdataFactory' => $metadataFactory));

$entityManager = new Zend_Entity_Manager(array('mapper' => $mapper, 'metadataFactory' => $metadataFactory));
]]>
        </programlisting>

        <para>
            There is currently a factory which does this, but it will probably be heavily rewritten,
            so this manual way has to suffice.
        </para>
    </sect2>

    <sect2 id="zend.entity.quickstart.querying">
        <title>Queries for Application Use-Cases</title>

        <para>
            Now that we have a running Entity Manager instance, we can discuss how to query the underlying
            mapper for the required data. When opening the application, bugs can be paginated through a
            list-view, which is the first use-case:
        </para>

        <programlisting language="php"><![CDATA[
$sqlQueryBuilder = new Zend_Db_Mapper_SqlQueryBuilder($entityManager);
$sqlQueryBuilder->fromEntity("Bug")
                ->order("bug_created DESC");

$bugs = $sqlQueryBuilder->getResultList();

foreach($bugs AS $bug) {
    echo $bug->description." - ".$bug->created->format('d.m.Y')."\n";
    echo "    Reported by: ".$bug->getReporter()->name."\n";
    echo "    Assigned to: ".$bug->getEngineer()->name."\n";
    foreach($bug->getProducts() AS $product) {
        echo "    Platform: ".$product->name."\n";
    }
    echo "\n";
}
]]>
        </programlisting>

        <para>
            The SQL Query Builder is a hybrid Query Object which makes allows you to build
            a query very much like using <classname>Zend_Db_Select</classname> however requires
            some references to which Entity is actually retrieved from the built SQL. This can be
            confusing on the first glance, but allows very powerful and flexible queries as we will see
            in a second.
        </para>

        <para>
            What happends in the first Use-Case query is that the call to <code>$sqlQueryBuilder->fromEntity($className);</code>
            adds "Bug" as entity to retrieve, internally detects that it needs to add the table "zfbugs" to the FROM clause
            and all of the Entities required columns to the SELECT clause of the query. For the order clause
            however the database column name has to be specified, no internal rewriting from property to column name
            happens here. In general one can say using the SqlQueryBuilder all the methods with the Suffix "Entity"
            can do some inference on how to translate the data into SQL, whereas all the other methods need raw SQL.
        </para>

        <para>
            So what if the query above is given as a stored procedure inside the database already? No problem:
            We can execute arbitrary SQL statements and map the resulting columns to entities and scalar values
            using the ResultSet Mapping pattern:
        </para>

        <programlisting language="php"><![CDATA[
$rsm = new Zend_Entity_Query_ResultSetMapping();
$rsm->addEntity("Bug", "b")
    ->addProperty("b", "bug_id", "id")
    ->addProperty("b", "bug_description", "description")
    ->addProperty("b", "bug_created", "created")
    ->addProperty("b", "reported_by", "reporter")
    ->addProperty("b", "assigned_to", "engineer");

$sql = "CALL GetBugs();";

$query = $entityManager->createNativeQuery($sql, $rsm);
$bugs = $query->getResultList();

foreach($bugs AS $bug) {
    echo $bug->description." - ".$bug->created->format('d.m.Y')."\n";
    echo "    Reported by: ".$bug->getReporter()->name."\n";
    echo "    Assigned to: ".$bug->getEngineer()->name."\n";
    foreach($bug->getProducts() AS $product) {
        echo "    Platform: ".$product->name."\n";
    }
    echo "\n";
}
]]>
        </programlisting>

        <para>
            This yields exactly the same result as the query before. Although its definately more verbose
            to use this way of querying the database, you can see that its way more flexible, giving you
            the possibility to transform almost every query into resulting entities. This example is
            also far from showing all the capabilities of the ResultSetMapping as we will see later.
        </para>

        <para>
            The next Use-Case is displaying a Bug by primary key. This could be done by restricing the examples
            with a where clause, however there is a convenience method on the Entity Manager that handles
            loading by primary key:
        </para>

        <programlisting language="php"><![CDATA[
$bug = $entityManager->load("Bug", (int)$theBugId);
]]>
        </programlisting>

        <para>
            The method <code>load($entityName, $key, $notFound="exception")</code> throws an
            <classname>Zend_Entity_NoResultException</classname> if the entity does not exist.
            However if you specifiy <code>$notFound="null"</code> it can also return null.
        </para>

        <para>
            The dashboard of the applicaton should also show all the reported or assigned bugs:
        </para>

        <programlisting language="php"><![CDATA[
$sqlQueryBuilder = new Zend_Db_Mapper_SqlQueryBuilder($entityManager);
$sqlQueryBuilder->fromEntity("Bug");
    ->where("assigned_to = ?", (int)$myUserId)
    ->orWhere("reported_by = ?", (int)$myUserId);

$myBugs = $sqlQueryBuilder->getResultList();
]]>
        </programlisting>

        <para>
            More complex queries and possibilities to create several entities from a single query are
            shown in the specific Query API sections of the Database storage later in this manual.
        </para>
        
    </sect2>

    <sect2 id="zend.entity.quickstart.persistence">
        <title>Making changes persistent</title>

        <para>
            Two requirements need changes to be persisted to the database again. Persistence mechanisms in
            Zend Entity are quite complex and depending on the options can work quite differently. This
            depends on two different options.
        </para>

        <itemizedlist>
            <listitem>
                Entity Manager Flush Mode: By default the Flush Mode is set to <code>Zend_Entity_Manager::FLUSHMODE_IMMEDIATE</code>
                which means that any call to <code>$entityManager->save($entityInstance)</code> or
                <code>$entityManager->delete($entityInstance)</code> will directly flush the action to the database.
                However the flush operation can also be deferred to a later stage and will then be executed
                by <code>$entityManager->flush()</code>.
            </listitem>
            <listitem>
                Entity Change Policy: By default the change policy is set to
                <code>Zend_Entity_Definition_Entity::EXPLICIT_PASSTHROUGH</code> which means that the Entity
                Manager requires an explicit call to <code>$entityManager->save()</code> or
                <code>$entityManager->delete()</code> to be registered and passthrough means, that
                no check will be made if persistent properties of the entity have actually changed or not.
            </listitem>
        </itemizedlist>

        <para>
            Other strategies with regard to the flush mode or change policy are described in the specific sections.
        </para>

        <para>
            The first use-case with regard to persistence is the saving of a new bug by a user:
        </para>

        <programlisting language="php"><![CDATA[
$product = $entityManager->load("Product", $theProductId);
$reporter = $entityManager->load("User", $theReporterId);
$engineer = $entityManager->load("User", $theDefaultEngineerId);

$bug = new Bug();
$bug->description = "Something does not work!";
$bug->addProduct($product);
$bug->setEngineer($engineer);
$bug->created = new DateTime("now");
$bug->status = "NEW";

$entityManager->save($bug);
echo "My Bug Id: ".$bug->id."\n";
]]>
        </programlisting>

        <para>
            The Entity Manager detects if the entity has to be saved or updated by checking in the identity map,
            if the entity has been retrieved from the database before or not. If the Entity was retrieved before
            it is in the identity map and has to be updated. If not it will be inserted into the database.
            However sometimes you want to save an entity which has an identity (id) but was detached from
            the persistence context for various reasons (sending to a remote server for example).
            You can merge any possible changes by calling <code>$entityManager->merge($entityInstance)</code>.
            (merge() is not implemented yet!!)
        </para>

        <para>
            The next use-case is the changing of the status of a bug to CLOSED.
        </para>

        <programlisting language="php"><![CDATA[
$bug = $entityManager->load("Bug", $theBugId);
$bug->status = "CLOSED";
$entityManager->save($bug);
]]>
        </programlisting>

    </sect2>

    <sect2 id="zend.entity.quickstart.transactions">
        <title>Using Transactions</title>

        
    </sect2>

    <sect2 id="zend.entity.quickstart.proxies">
        <title>Generating Lazy Load Proxies</title>
        
    </sect2>

    <sect2 id="zend.entity.quickstart.php52">
        <title>Property Access Strategies for PHP 5.2</title>
        
    </sect2>
</sect1>