TODO

Dependent on Tasks:
* Zend_Db_Adapter needs abstraction for ANSI-SQL functions - http://framework.zend.com/issues/browse/ZF-5686
* Zend_Db_Select needs abstraction for complex and/or queries (using combine()) - http://framework.zend.com/issues/browse/ZF-7444

Tasks:
* Refactoring to Definition Visitor to decouple RMDBS storage from common metadata definitions.
* Implement Handling of NotFound property
* Extend EventListener to get more context related information
* Mapper Refactoring + EntityManager: Decouple Zend_Db_Adapter into the Mapper
* Add Property Change Listener strategy variables, add "EXPLICIT" as only implementation for now (using save() and delete())
* Extend Object and Array Hydration to include multiple entity loading at once.
* Implement Scalar Hydration Mode that can be used for Aggregate and Single Result queries, code it into query object.
* Type Casting: Test it and maybe be split up Property Definition into different types if this is a bottleneck
* Collections: Add difference between Set, Map and List. Add ordering mechanism and allow to set own implementations.
* Remove Zend_Entity_Interface typehint everywhere
* Query API: Query Object in Domain Speak translating all properties and foreign entity access to internal SQL.
* Implement StateTransformer with ReflectionProperty and PHP 5.3 setAccessible()
* Evaluate Related Object has to be done after saving the original entity to ensure aggregate consistency. (Done, Tests please!!)
* Definitions: Add "component" property and RMDBS storage implementation
* Definitions: Add compound keys through a PrimaryKey object.
* Proxy Option for Entities:
    * Possible values "generic", "dynamic, "static"?
    * Class has to be overwritable to implement the Entity interface that fakes identity. (See Providers)
* Mapper: Save and Delete
    * Implement Cascading Persisters
* Persister/Loader: Handle Bi-directional relationsships according to EJB standard.
    * How to handle one to many relations only? (Idea: Owning a ManyToMany with Unique foreign key)
    * Other idea: Require a connection table which works much like many to many (EJB way)
    * Add Cascading options for Orphans and such
* Zend Tool Providers:
    * Code-Generation for LazyLoad Proxies
        * Give path to metadata definitions
        * Give Path to directory
        * Create lazy load proxies from the current entity classes
    * Metadata to SQL Generation
        * Give Metadata definitions
        * Generate SQL DDL statements
        * Intermediate format (ezComponents DbSchema?) which allows to generate diffs between metadata versions.
    * SQL to Metadata Generation
        * Give SQL database structure (ezComponents DbSchema?)
        * Create superficial Metadata definitions (programmatic)
* Configuration Metadata via XML

Version 1.1
* Mapper: merge/refresh() method needs specific API method on the loader to be useful
* Mapper: Implement new loaders and persisters for Inheritence mapping
* Unit Of Work Session Decorator
  * Force entities to implement interface "Footprint", which has to be userland implemented to notify unit of work of changes
  * On commit, walk over all entities that are in the context and compare footprint to the original one.
* EntityManager: Implement Second Level Cache into IdentityMap - Zend_Cache holds objects in Cache for a lifetime, re-cached on each change
    * Easy: Cachable are only the Database representations of an object, not the object itsself. This way all the objects are saved on their own
    * Dependency: Implement Registry or Factory for EntityManager, allowing to serialize/deserialize Lazy Load collections corretcly
* Allow to query for mixed results


Workable Tests:
* Self referencing objects
* Association table loading
* Persisting collections